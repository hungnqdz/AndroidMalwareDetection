import pandas as pd
import torch
import torch_geometric
from torch_geometric.data import Dataset, Data
import numpy as np
import os
from AndroidMalwareDetection.FCG.reversed import AndroGuard
import glob
from torch_geometric.data.makedirs import makedirs
from AndroidMalwareDetection.Feature.extract_feature.extract_feature import ExtractFeature
from concurrent.futures import ThreadPoolExecutor
from gensim.models import word2vec

class GraphDataset(Dataset):
    def __init__(self, root, filename = [],transform=None, pre_transform=None,label = 1,path_dataset = '',api2vec = None,opcode2vec = None, is_loading = False,num_thread = 20,start_index = 0):
        """
        root = Where the dataset should be stored. This folder is split
        into raw_dir (downloaded dataset) and processed_dir (processed data).
        """
        self.label = label
        processed_dir = os.path.join(root, "processed")
        makedirs(processed_dir)
        self.filename = filename
        self.path_dataset = path_dataset
        self.api2vec = api2vec
        self.opcode2vec = opcode2vec
        self.num_thread = num_thread
        self.is_loading = is_loading
        self.start_index = start_index
        self.len_data = len(glob.glob(os.path.join(processed_dir, 'data_graph*.pt')))
        super(GraphDataset, self).__init__(root, transform, pre_transform)

    @property
    def raw_file_names(self):
        return ''

    def download(self):
        pass

    def process_file(self, filename, index):
      path = self.path_dataset + '/' + filename
      if os.path.exists(os.path.join(self.processed_dir, f'data_graph{index}.pt')): return
      with open("browsing_log.txt", "a") as log_file:
              log_file.write(f"File {filename} {index}\n")
      try:
          extract = ExtractFeature(path, self.api2vec, self.opcode2vec)
          data = extract.to_data(self.label)
          torch.save(data,
                   os.path.join(self.processed_dir,
                                f'data_graph{index}.pt'))
          with open("success_log.txt", "a") as log_file:
              log_file.write(f"File {filename} saved successfully with index {index}\n")
          self.len_data = len(glob.glob(os.path.join(self.processed_dir, 'data_graph*.pt')))
      except Exception as e:
          print(f"An exception occurred with file {filename} {index}: {e}\n")
          with open("error_log.txt", "a") as error_file:
              error_file.write(f"An exception occurred with file {filename} {index}: {e}\n")

    @property
    def processed_file_names(self):
        return self.filename

    def process(self):
        self.len_data = len(glob.glob(os.path.join(self.processed_dir, 'data_graph*.pt')))
        if(self.is_loading): return
        with ThreadPoolExecutor(max_workers=self.num_thread) as executor:
            futures = [executor.submit(self.process_file, os.listdir(self.path_dataset)[index], index)
                       for index in range(self.start_index, len(os.listdir(self.path_dataset)))]
            for future in futures:
                future.result()


    def len(self):
        return self.len_data

    def get(self, idx):
        data = torch.load(os.path.join(self.processed_dir,
                                 f'data_graph{idx}.pt'))
        return data