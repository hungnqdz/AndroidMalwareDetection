from AndroidMalwareDetection.FCG.reversed import AndroGuard
from gensim.models import word2vec
import numpy as np
import re
import torch
import networkx as nx
import torch_geometric.utils


class ExtractFeature():
    def __init__(self, path_apk, api2vec, opcode2vec, is_prune=False):
        self.andro = AndroGuard(path_apk,is_prune)
        self.api2vec = api2vec
        self.opcode2vec = opcode2vec

    @staticmethod
    def average_vectors(vectors):
        if len(vectors) == 0:
            return None

        vector_shape = vectors[0].shape
        for vector in vectors:
            if vector.shape != vector_shape:
                raise ValueError("All vectors must have the same shape")

        avg_vector = np.zeros(vector_shape)
        for vector in vectors:
            avg_vector += vector
        avg_vector /= len(vectors)

        return avg_vector

    @staticmethod
    def concatenate_vectors(vectors, axis=0):
        if len(vectors) == 0:
            return None
        print(vectors)
        vector_shape = vectors[0].shape
        concatenated_vector = np.concatenate(vectors, axis=axis)

        return concatenated_vector

    def pre_data(self, result):
        string_without_dollar = result.replace("$", " ")
        string_without_digits = ''.join(char for char in string_without_dollar if not char.isdigit())
        final = re.sub(r'\s+', ' ', string_without_digits)
        return final

    def preprocessing_package(self, api):
        package = api.split(';')[0]
        package_line = package.split('/')
        result = ''
        for p in package_line:
            result += str(p).lower() + ' '
        return self.pre_data(result.strip())

    def extract_api_vector(self, method):
        if not method.is_external():
            return np.zeros(int(self.api2vec.wv.vectors.shape[1]))

        vectors_list = []
        method_name = self.preprocessing_package(api=method.class_name).split(' ')
        for m in method_name:
            try:
                vectors = self.api2vec.wv[str(m)]
                vectors_list.append(vectors)
            except KeyError as ke:
                print(ke)
                continue
        # print(vectors_list)
        if len(vectors_list) == 0: return np.zeros(int(self.api2vec.wv.vectors.shape[1]))
        return self.average_vectors(vectors_list)

    def extract_opcode_vector(self, method):
        # print(method.get_method())
        flag = method.get_method().get_access_flags_string()
        if method.is_external() or "abstract" in flag or 'native' in flag:
            return np.zeros(int(self.opcode2vec.wv.vectors.shape[1]))

        vectors_list = []
        for ins in method.get_method().get_instructions():
            vector = self.opcode2vec.wv[str(ins.get_name())]
            vectors_list.append(vector)

        return self.average_vectors(vectors_list)

    def get_method_feature(self, method):
        api_vector = self.extract_api_vector(method)
        opcode_vector = self.extract_opcode_vector(method)
        print(method.get_method())
        concat_vec = self.concatenate_vectors([api_vector, opcode_vector])
        deg = self.andro.cg.degree(method)
        num_node = self.andro.cg.number_of_nodes()
        vec = concat_vec * (deg / num_node - 1)
        return vec

    def get_all_external_features(self, head=-1):
        vectors = []
        for m in self.andro.dx.get_methods():
            if head == 0: return vectors
            if m.is_external():
                feature = self.get_method_feature(m)
                vectors.append(feature)
                head -= 1

        return torch.from_numpy(np.array(vectors))

    def get_all_non_external_features(self, head=-1):
        vectors = []
        for m in self.andro.dx.get_methods():
            if head == 0: return vectors
            if not m.is_external():
                feature = self.get_method_feature(m)
                vectors.append(feature)
                head -= 1

        return torch.from_numpy(np.array(vectors))

    def get_all_features(self, head=-1):
        vectors = []
        for m in self.andro.dx.get_methods():
            if (head == 0): return vectors
            feature = self.get_method_feature(m)
            vectors.append(feature)
            head -= 1

        return torch.from_numpy(np.array(vectors))

    def get_graph_with_feature(self):
        cg = self.andro.cg
        mapping = {}
        for node in cg.nodes:
            mapping[node] = self.get_method_feature(node)
        nx.set_node_attributes(cg, mapping, 'vectors')
        return cg

    def to_data(self, label):
        cg = self.get_graph_with_feature()
        cg = nx.convert_node_labels_to_integers(cg)
        data = torch_geometric.utils.from_networkx(group_node_attrs=['vectors'], G=cg)
        data.y = torch.tensor(label)
        return data
